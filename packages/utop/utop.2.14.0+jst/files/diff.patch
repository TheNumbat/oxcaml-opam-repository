diff --git a/src/lib/uTop.ml b/src/lib/uTop.ml
index 801fd29..0af712b 100644
--- a/src/lib/uTop.ml
+++ b/src/lib/uTop.ml
@@ -298,6 +298,9 @@ let parse_default parse str eos_is_error =
              Hint: Mutable sequences of bytes are available in the Bytes module.\n\
              Hint: Did you mean to use 'Bytes.set'?")
 #endif
+      | Syntaxerr.Missing_unboxed_literal_suffix loc ->
+        Error ([mkloc loc],
+               Printf.sprintf "Syntax error: Unboxed integer literals require width suffixes.")
     end
     | Syntaxerr.Escape_error | Parsing.Parse_error ->
         Error ([mkloc (Location.curr lexbuf)],
diff --git a/src/lib/uTop_compat.ml b/src/lib/uTop_compat.ml
index 60c8adf..4b4fcd8 100644
--- a/src/lib/uTop_compat.ml
+++ b/src/lib/uTop_compat.ml
@@ -59,7 +59,7 @@ let toploop_load_file ppf fn =
 
 (** Returns whether the given path is persistent. *)
 let rec is_persistent_path = function
-  | Path.Pident id -> Ident.persistent id
+  | Path.Pident id -> Ident.is_global_or_predef id
   | Path.Pdot (p, _) -> is_persistent_path p
   | Path.Papply (_, p) -> is_persistent_path p
 #if OCAML_VERSION >= (5, 1, 0)
diff --git a/src/lib/uTop_complete.ml b/src/lib/uTop_complete.ml
index 7f480dd..48bbc91 100644
--- a/src/lib/uTop_complete.ml
+++ b/src/lib/uTop_complete.ml
@@ -408,7 +408,7 @@ let add_fields_of_type decl acc =
         List.fold_left (fun acc field -> add (field_name field) acc) acc fields
 #if OCAML_VERSION >= (5, 2, 0)
     | Type_abstract _ ->
-#else 
+#else
     | Type_abstract ->
 #endif
         acc
@@ -427,7 +427,7 @@ let add_names_of_type decl acc =
         List.fold_left (fun acc field -> add (field_name field) acc) acc fields
 #if OCAML_VERSION >= (5, 2, 0)
     | Type_abstract _ ->
-#else 
+#else
     | Type_abstract ->
 #endif
         acc
@@ -531,7 +531,7 @@ let list_global_names () =
     | Env.Env_empty -> acc
     | Env.Env_value_unbound _-> acc
     | Env.Env_module_unbound _-> acc
-    | Env.Env_value(summary, id, _) ->
+    | Env.Env_value(summary, id, _, _) ->
         loop (add (Ident.name id) acc) summary
     | Env.Env_type(summary, id, decl) ->
         loop (add_names_of_type decl (add (Ident.name id) acc)) summary
@@ -585,7 +585,7 @@ let list_global_fields () =
     | Env.Env_empty -> acc
     | Env.Env_value_unbound _-> acc
     | Env.Env_module_unbound _-> acc
-    | Env.Env_value(summary, id, _) ->
+    | Env.Env_value(summary, id, _, _) ->
         loop (add (Ident.name id) acc) summary
     | Env.Env_type(summary, id, decl) ->
         loop (add_fields_of_type decl (add (Ident.name id) acc)) summary
@@ -709,11 +709,11 @@ let rec labels_of_type acc type_expr =
         labels_of_type acc te
     | Tpoly (te, _) ->
         labels_of_type acc te
-    | Tarrow(label, _, te, _) ->
+    | Tarrow((label, _, _), _, te, _) ->
       (match label with
       | Nolabel ->
         labels_of_type acc te
-      | Optional label ->
+      | Position label | Optional label ->
         labels_of_type (String_map.add label Optional acc) te
       | Labelled label ->
         labels_of_type (String_map.add label Required acc) te)
diff --git a/src/lib/uTop_main.ml b/src/lib/uTop_main.ml
index 1836e62..7267b36 100644
--- a/src/lib/uTop_main.ml
+++ b/src/lib/uTop_main.ml
@@ -295,102 +295,6 @@ class read_phrase ~term = object(self)
     self#set_prompt !UTop.prompt
 end
 
-(* +-----------------------------------------------------------------+
-   | Handling of [@@toplevel_printer] attributes                     |
-   +-----------------------------------------------------------------+ *)
-
-module Autoprinter : sig
-  val scan_env : Format.formatter -> unit
-
-  val scan_cmis : Format.formatter -> unit
-end = struct
-  open Types
-
-  let cons_path path id =
-    let comp = Ident.name id in
-    match path with
-    | None -> Longident.Lident comp
-    | Some path -> Longident.Ldot (path, comp)
-
-  let is_auto_printer_attribute (attr : Parsetree.attribute) =
-    let name = attr.attr_name in
-    match name.txt with
-    | "toplevel_printer" | "ocaml.toplevel_printer" -> true
-    | _ -> false
-
-  let rec walk_sig pp ~path signature =
-    List.iter (walk_sig_item pp (Some path)) signature
-
-  and walk_sig_item pp path = function
-    | Sig_module (id, _, {md_type = mty; _}, _, _) ->
-        walk_mty pp (cons_path path id) mty
-    | Sig_value (id, vd, _) ->
-      if List.exists is_auto_printer_attribute vd.val_attributes then
-        Topdirs.dir_install_printer pp (cons_path path id)
-    | _ -> ()
-
-  and walk_mty pp path = function
-    | Mty_signature s -> walk_sig pp ~path s
-    | _ -> ()
-
-  let scan_cmis =
-    let new_cmis = ref [] in
-    UTop_compat.add_cmi_hook (fun cmi -> new_cmis := cmi :: !new_cmis );
-    fun pp ->
-      List.iter (fun (cmi : Cmi_format.cmi_infos) ->
-        walk_sig pp ~path:(Longident.Lident cmi.cmi_name) cmi.cmi_sign
-      ) !new_cmis;
-      new_cmis := []
-
-  let scan_env =
-    let last_globals = ref (Env.get_required_globals ()) in
-    let last_summary = ref Env.Env_empty in
-    fun pp ->
-      let env = !Toploop.toplevel_env in
-      let scan_module env id =
-        let name = Longident.Lident (Ident.name id) in
-        let path, {md_type; _} = Env.find_module_by_name name env in
-        if path = Path.Pident id then
-          walk_mty pp name md_type
-      in
-      let rec scan_globals last = function
-        | [] -> ()
-        | x when x == last -> ()
-        | x :: xs ->
-          scan_globals last xs;
-          scan_module env x
-      in
-      let rec scan_summary last = function
-        | Env.Env_empty -> ()
-        | x when x == last -> ()
-        | Env.Env_module (s, id, _, _) ->
-          scan_summary last s;
-          scan_module env id
-        | Env.Env_copy_types s
-        | Env.Env_value_unbound (s, _, _)
-        | Env.Env_module_unbound (s, _, _)
-        | Env.Env_persistent (s, _)
-        | Env.Env_value (s, _, _)
-        | Env.Env_type (s, _, _)
-        | Env.Env_extension (s, _, _)
-        | Env.Env_modtype (s, _, _)
-        | Env.Env_class (s, _, _)
-        | Env.Env_cltype (s, _, _)
-        | Env.Env_open (s, _)
-        | Env.Env_functor_arg (s, _)
-        | Env.Env_constraints (s, _) ->
-          scan_summary last s
-      in
-      let globals = Env.get_required_globals () in
-      let last_globals' = !last_globals in
-      last_globals := globals;
-      scan_globals last_globals' globals;
-      let summary = Env.summary env in
-      let last_summary' = !last_summary in
-      last_summary := summary;
-      scan_summary last_summary' summary
-end
-
 let render_out_phrase term string =
   if String.length string >= 100 * 1024 then
     LTerm.fprint term string
@@ -490,7 +394,6 @@ let print_out_signature pp items =
     orig_print_out_signature pp items
 
 let print_out_phrase pp phrase =
-  Autoprinter.scan_env pp;
   if UTop.get_hide_reserved () then
     let phrase =
       match phrase with
@@ -627,7 +530,7 @@ let rewrite_str_item pstr_item tstr_item =
   match pstr_item, tstr_item.Typedtree.str_desc with
     | ({ Parsetree.pstr_desc = Parsetree.Pstr_eval (e, _);
          Parsetree.pstr_loc = loc },
-       Typedtree.Tstr_eval ({ Typedtree.exp_type = typ }, _)) -> begin
+       Typedtree.Tstr_eval ({ Typedtree.exp_type = typ }, _, _)) -> begin
       match rule_of_type typ with
         | Some rule ->
           { Parsetree.pstr_desc = Parsetree.Pstr_eval (rule.rewrite loc e, []);
@@ -678,11 +581,7 @@ let bind_expressions name phrase =
     | Parsetree.Ptop_dir _ ->
       phrase
 
-let execute_phrase b ppf phrase =
-  Autoprinter.scan_cmis ppf;
-  let res = Toploop.execute_phrase b ppf phrase in
-  Autoprinter.scan_cmis ppf;
-  res
+let execute_phrase b ppf phrase = Toploop.execute_phrase b ppf phrase
 
 (* +-----------------------------------------------------------------+
    | Main loop                                                       |
@@ -1521,8 +1420,9 @@ type value = V : string * _ -> value
 exception Found of Env.t
 
 let get_required_label name args =
-  match List.find (fun (lab, _) -> lab = Asttypes.Labelled name) args with
-  | _, x -> x
+  match List.find (fun (lab, _) -> lab = Typedtree.Labelled name) args with
+  | _, Typedtree.Omitted _ -> None
+  | _, Typedtree.Arg (x, _) -> Some x
   | exception Not_found -> None
 
 let walk dir ~init ~f =
@@ -1557,7 +1457,7 @@ let interact ?(search_path=[]) ?(build_dir="_build") ~unit ~loc:(fname, lnum, cn
   let cmt_infos = Cmt_format.read_cmt cmt_fname in
   let expr next (e : Typedtree.expression) =
     match e.exp_desc with
-        | Texp_apply (_, args) -> begin
+        | Texp_apply (_, args, _, _, _) -> begin
             try
               match get_required_label "loc"    args,
                     get_required_label "values" args
