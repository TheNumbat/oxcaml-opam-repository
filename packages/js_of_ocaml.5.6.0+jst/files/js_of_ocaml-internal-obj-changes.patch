diff --git a/compiler/lib/generate.ml b/compiler/lib/generate.ml
--- a/compiler/lib/generate.ml
+++ b/compiler/lib/generate.ml
@@ -1113,8 +1113,6 @@ let _ =
   register_tern_prim "caml_array_unsafe_set" (fun cx cy cz _ ->
       J.EBin (J.Eq, Mlvalue.Array.field cx cy, cz));
   register_un_prim "caml_alloc_dummy" `Pure (fun _ _ -> J.array []);
-  register_un_prim "caml_obj_dup" `Mutable (fun cx loc ->
-      J.call (J.dot cx (Utf8_string.of_string_exn "slice")) [] loc);
   register_un_prim "caml_int_of_float" `Pure (fun cx _loc -> to_int cx);
   register_un_math_prim "caml_abs_float" "abs";
   register_un_math_prim "caml_acos_float" "acos";
diff --git a/compiler/tests-compiler/obj.ml b/compiler/tests-compiler/obj.ml
--- a/compiler/tests-compiler/obj.ml
+++ b/compiler/tests-compiler/obj.ml
@@ -50,13 +50,13 @@ let%expect_test "static eval of string g
     //end
     function my_tag(x){return runtime.caml_obj_tag([0, x, 0]);}
     //end
-    function my_size(x){return x.length - 1;}
+    function my_size(x){return caml_call1(Stdlib_Obj[2], x);}
     //end
-    function my_field(x, i){return x[1 + i];}
+    function my_field(x, i){return caml_call2(Stdlib_Obj[5], x, i);}
     //end
-    function my_set_field(x, i, o){x[1 + i] = o; return 0;}
+    function my_set_field(x, i, o){return caml_call3(Stdlib_Obj[6], x, i, o);}
     //end
     function my_new_block(x, l){return runtime.caml_obj_block(x + 1 | 0, 3);}
     //end
-    function my_dup(t){return [0, t, 0].slice();}
+    function my_dup(t){return runtime.caml_obj_dup([0, t, 0]);}
     //end |}]
diff --git a/compiler/tests-compiler/obj_dup.ml b/compiler/tests-compiler/obj_dup.ml
--- a/compiler/tests-compiler/obj_dup.ml
+++ b/compiler/tests-compiler/obj_dup.ml
@@ -28,7 +28,7 @@ let%expect_test _ =
     let print_bool b = print_endline (string_of_bool b)
     let () =
       let s = "Hello" in
-      let s' : string = Obj.obj (Obj.dup (Obj.repr s)) in
+      let s' : string = Obj.obj (Obj.dup (Obj.repr (Sys.opaque_identity s))) in
       print_bool (s = s');
       print_bool (s != s')
   |};
@@ -44,7 +44,7 @@ let%expect_test _ =
     let print_bool b = print_endline (string_of_bool b)
     let () =
       let s = Bytes.of_string "Hello" in
-      let s' : bytes = Obj.obj (Obj.dup (Obj.repr s)) in
+      let s' : bytes = Obj.obj (Obj.dup (Obj.repr (Sys.opaque_identity s))) in
       print_bool (s = s');
       print_bool (s != s');
       Bytes.set s' 1 'a';
@@ -63,7 +63,7 @@ let%expect_test _ =
     let print_bool b = print_endline (string_of_bool b)
     let () =
       let s = "Hello" in
-      let s' : string = Obj.obj (Obj.dup (Obj.repr s)) in
+      let s' : string = Obj.obj (Obj.dup (Obj.repr (Sys.opaque_identity s))) in
       print_bool (s = s');
       print_bool (s != s')
   |};
@@ -79,7 +79,7 @@ let%expect_test _ =
     let print_bool b = print_endline (string_of_bool b)
     let () =
       let s = Bytes.of_string "Hello" in
-      let s' : bytes = Obj.obj (Obj.dup (Obj.repr s)) in
+      let s' : bytes = Obj.obj (Obj.dup (Obj.repr (Sys.opaque_identity s))) in
       print_bool (s = s');
       print_bool (s != s');
       Bytes.set s' 1 'a';
diff --git a/lib/tests/test_fun_call.ml b/lib/tests/test_fun_call.ml
--- a/lib/tests/test_fun_call.ml
+++ b/lib/tests/test_fun_call.ml
@@ -388,26 +388,26 @@ let%expect_test _ =
     | Invalid_argument s | Failure s -> Printf.printf "Error: %s" s
     | _ -> Printf.printf "Error: unknown"
   in
   (*
-  f (Obj.magic cb1);
+  f (Sys.opaque_identity (Obj.magic cb1));
   [%expect {|
     got 1, done
     Result: 0 |}];
-  f (Obj.magic cb2);
+  f (Sys.opaque_identity (Obj.magic cb2));
   [%expect {|
     got 1, 2, done
     Result: 0 |}];
 *)
-  f (Obj.magic cb3);
+  f (Sys.opaque_identity (Obj.magic cb3));
   [%expect {|
     got 1, 2, 3, done
     Result: 0 |}];
-  f (Obj.magic cb4);
+  f (Sys.opaque_identity (Obj.magic cb4));
   [%expect {|
     Result: other |}];
-  f (Obj.magic cb5);
+  f (Sys.opaque_identity (Obj.magic cb5));
   [%expect {|
     Result: other |}]

 let%expect_test _ =
   let open Js_of_ocaml in
diff --git a/runtime/obj.js b/runtime/obj.js
--- a/runtime/obj.js
+++ b/runtime/obj.js
@@ -69,11 +69,49 @@ function caml_obj_with_tag(tag,x) {
 }

 //Provides: caml_obj_dup mutable (mutable)
+//Requires: MlInt64, MlBytes, caml_failwith
 function caml_obj_dup (x) {
-  var l = x.length;
-  var a = new Array(l);
-  for(var i = 0; i < l; i++ ) a[i] = x[i];
-  return a;
+  switch (typeof x) {
+    case 'number':
+    case 'bigint':
+    case 'boolean':
+    case 'undefined':
+    case 'function':
+    case 'string': return x;
+    case 'object': {
+      if (x === null || x instanceof MlInt64) {
+        return x;
+      }
+
+      if (x instanceof MlBytes) {
+        if (typeof x.c === 'string') {
+          // we can re-use the content because strings are immutable
+          return new MlBytes(x.t, x.c, x.l);
+        } else {
+          // it must be an array, as defined in ./mlBytes.js
+          var content = Array.prototype.slice.call(x.c);
+          return new MlBytes(x.t, content, x.l);
+        }
+      }
+
+      if (x instanceof Array) {
+        return Array.prototype.slice.call(x);
+      }
+
+      // if we get here, then we want to fallback to the default
+      // case, which will end with the error handling.
+    }
+    default: break
+  }
+
+  try {
+    // printing the value as a string and json-stringifying can both fail,
+    // so wrap it in a try/catch with a less useful error message
+    var as_json = globalThis.JSON.stringify(x);
+    caml_failwith("caml_obj_dup called on unknown value: " + x + " " + as_json)
+  } catch (_) {
+    caml_failwith("caml_obj_dup called on unknown value");
+  }
 }

 //Provides: caml_obj_truncate (mutable, const)
