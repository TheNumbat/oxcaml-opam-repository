--- a/astlib/ast_414.ml
+++ b/astlib/ast_414.ml
@@ -90,6 +90,16 @@ module Parsetree = struct
 
   type location_stack = Location.t list
 
+  type modality (*IF_CURRENT = Parsetree.modality *) = | Modality of string [@@unboxed]
+  type modalities = modality loc list
+
+  type mode (*IF_CURRENT = Parsetree.mode *)= | Mode of string [@@unboxed]
+  type modes = mode loc list
+
+  type include_kind (*IF_CURRENT = Parsetree.include_kind *) =
+    | Structure
+    | Functor
+
   (** {1 Extension points} *)
 
   type attribute (*IF_CURRENT = Parsetree.attribute *) = {
@@ -106,7 +116,7 @@ module Parsetree = struct
   and extension = string loc * payload
   (** Extension points such as [[%id ARG] and [%%id ARG]].
 
-     Sub-language placeholder -- rejected by the typechecker.
+      Sub-language placeholder -- rejected by the typechecker.
   *)
 
   and attributes = attribute list
@@ -132,18 +142,27 @@ module Parsetree = struct
   and core_type_desc (*IF_CURRENT = Parsetree.core_type_desc *) =
     | Ptyp_any  (** [_] *)
     | Ptyp_var of string  (** A type variable such as ['a] *)
-    | Ptyp_arrow of arg_label * core_type * core_type
-        (** [Ptyp_arrow(lbl, T1, T2)] represents:
-              - [T1 -> T2]    when [lbl] is
+    | Ptyp_arrow of arg_label * core_type * core_type * modes * modes
+        (** [Ptyp_arrow(lbl, T1, T2, M1, M2)] represents:
+              - [T1 @ M1 -> T2 @ M2]    when [lbl] is
                                        {{!Asttypes.arg_label.Nolabel}[Nolabel]},
-              - [~l:T1 -> T2] when [lbl] is
+              - [~l:(T1 @ M1) -> T2 @ M2] when [lbl] is
                                        {{!Asttypes.arg_label.Labelled}[Labelled]},
-              - [?l:T1 -> T2] when [lbl] is
+              - [?l:(T1 @ M1) -> T2 @ M2] when [lbl] is
                                        {{!Asttypes.arg_label.Optional}[Optional]}.
            *)
-    | Ptyp_tuple of core_type list
-        (** [Ptyp_tuple([T1 ; ... ; Tn])]
-            represents a product type [T1 * ... * Tn].
+    | Ptyp_tuple of (string option * core_type) list
+        (** [Ptyp_tuple(tl)] represents a product type:
+            - [T1 * ... * Tn]       when [tl] is [(None,T1);...;(None,Tn)]
+            - [L1:T1 * ... * Ln:Tn] when [tl] is [(Some L1,T1);...;(Some Ln,Tn)]
+            - A mix, e.g. [L1:T1 * T2] when [tl] is [(Some L1,T1);(None,T2)]
+
+             Invariant: [n >= 2].
+          *)
+    | Ptyp_unboxed_tuple of (string option * core_type) list
+        (** Unboxed tuple types: [Ptyp_unboxed_tuple([(Some l1,P1);...;(Some l2,Pn)]]
+            represents a product type [#(l1:T1 * ... * l2:Tn)], and the labels
+            are optional.
 
              Invariant: [n >= 2].
           *)
@@ -166,7 +185,7 @@ module Parsetree = struct
               - [T #tconstr]             when [l=[T]],
               - [(T1, ..., Tn) #tconstr] when [l=[T1 ; ... ; Tn]].
            *)
-    | Ptyp_alias of core_type * string  (** [T as 'a]. *)
+    | Ptyp_alias of core_type * string loc  (** [T as 'a]. *)
     | Ptyp_variant of row_field list * closed_flag * label list option
         (** [Ptyp_variant([`A;`B], flag, labels)] represents:
               - [[ `A|`B ]]
@@ -273,10 +292,26 @@ module Parsetree = struct
 
              Other forms of interval are recognized by the parser
              but rejected by the type-checker. *)
-    | Ppat_tuple of pattern list
-        (** Patterns [(P1, ..., Pn)].
+    | Ppat_tuple of (string option * pattern) list * Asttypes.closed_flag
+        (** [Ppat_tuple(pl, Closed)] represents
+            - [(P1, ..., Pn)]       when [pl] is [(None, P1);...;(None, Pn)]
+            - [(~L1:P1, ..., ~Ln:Pn)] when [pl] is
+              [(Some L1, P1);...;(Some Ln, Pn)]
+            - A mix, e.g. [(~L1:P1, P2)] when [pl] is [(Some L1, P1);(None, P2)]
+            - If pattern is open, then it also ends in a [..]
 
-             Invariant: [n >= 2]
+            Invariant:
+            - If Closed, [n >= 2].
+            - If Open, [n >= 1].
+        *)
+    | Ppat_unboxed_tuple of (string option * pattern) list * Asttypes.closed_flag
+        (** Unboxed tuple patterns: [#(l1:P1, ..., ln:Pn)] is [([(Some
+            l1,P1);...;(Some l2,Pn)], Closed)], and the labels are optional.  An
+            [Open] pattern ends in [..].
+
+            Invariant:
+            - If Closed, [n >= 2]
+            - If Open, [n >= 1]
           *)
     | Ppat_construct of Longident.t loc * (string loc list * pattern) option
         (** [Ppat_construct(C, args)] represents:
@@ -302,7 +337,11 @@ module Parsetree = struct
            *)
     | Ppat_array of pattern list  (** Pattern [[| P1; ...; Pn |]] *)
     | Ppat_or of pattern * pattern  (** Pattern [P1 | P2] *)
-    | Ppat_constraint of pattern * core_type  (** Pattern [(P : T)] *)
+    | Ppat_constraint of pattern * core_type option * modes
+        (** [Ppat_constraint(tyopt, modes)] represents:
+            - [(P : ty @@ modes)] when [tyopt] is [Some ty]
+            - [(P @ modes)] when [tyopt] is [None]
+           *)
     | Ppat_type of Longident.t loc  (** Pattern [#tconst] *)
     | Ppat_lazy of pattern  (** Pattern [lazy P] *)
     | Ppat_unpack of string option loc
@@ -341,30 +380,21 @@ module Parsetree = struct
               - [let rec P1 = E1 and ... and Pn = EN in E]
                  when [flag] is {{!Asttypes.rec_flag.Recursive}[Recursive]}.
            *)
-    | Pexp_function of case list  (** [function P1 -> E1 | ... | Pn -> En] *)
-    | Pexp_fun of arg_label * expression option * pattern * expression
-        (** [Pexp_fun(lbl, exp0, P, E1)] represents:
-              - [fun P -> E1]
-                        when [lbl] is {{!Asttypes.arg_label.Nolabel}[Nolabel]}
-                         and [exp0] is [None]
-              - [fun ~l:P -> E1]
-                        when [lbl] is {{!Asttypes.arg_label.Labelled}[Labelled l]}
-                         and [exp0] is [None]
-              - [fun ?l:P -> E1]
-                        when [lbl] is {{!Asttypes.arg_label.Optional}[Optional l]}
-                         and [exp0] is [None]
-              - [fun ?l:(P = E0) -> E1]
-                        when [lbl] is {{!Asttypes.arg_label.Optional}[Optional l]}
-                         and [exp0] is [Some E0]
+    | Pexp_function of
+        function_param list * function_constraint option * function_body
+    (** [Pexp_function ([P1; ...; Pn], C, body)] represents any construct
+        involving [fun] or [function], including:
+        - [fun P1 ... Pn -> E]
+          when [body = Pfunction_body E]
+        - [fun P1 ... Pn -> function p1 -> e1 | ... | pm -> em]
+          when [body = Pfunction_cases [ p1 -> e1; ...; pm -> em ]]
 
-             Notes:
-             - If [E0] is provided, only
-               {{!Asttypes.arg_label.Optional}[Optional]} is allowed.
-             - [fun P1 P2 .. Pn -> E1] is represented as nested
-               {{!expression_desc.Pexp_fun}[Pexp_fun]}.
-             - [let f P = E] is represented using
-               {{!expression_desc.Pexp_fun}[Pexp_fun]}.
-           *)
+        [C] represents a type constraint or coercion placed immediately before the
+        arrow, e.g. [fun P1 ... Pn : ty -> ...] when [C = Some (Pconstraint ty)].
+
+        A function must have parameters. [Pexp_function (params, _, body)] must
+        have non-empty [params] or a [Pfunction_cases _] body.
+    *)
     | Pexp_apply of expression * (arg_label * expression) list
         (** [Pexp_apply(E0, [(l1, E1) ; ... ; (ln, En)])]
               represents [E0 ~l1:E1 ... ~ln:En]
@@ -380,11 +410,24 @@ module Parsetree = struct
         (** [match E0 with P1 -> E1 | ... | Pn -> En] *)
     | Pexp_try of expression * case list
         (** [try E0 with P1 -> E1 | ... | Pn -> En] *)
-    | Pexp_tuple of expression list
-        (** Expressions [(E1, ..., En)]
+    | Pexp_tuple of (string option * expression) list
+        (** [Pexp_tuple(el)] represents
+            - [(E1, ..., En)]
+              when [el] is [(None, E1);...;(None, En)]
+            - [(~L1:E1, ..., ~Ln:En)]
+              when [el] is [(Some L1, E1);...;(Some Ln, En)]
+            - A mix, e.g.:
+              [(~L1:E1, E2)] when [el] is [(Some L1, E1); (None, E2)]
 
              Invariant: [n >= 2]
           *)
+    | Pexp_unboxed_tuple of (string option * expression) list
+        (** Unboxed tuple expressions: [Pexp_unboxed_tuple([(Some l1,P1);...;(Some
+            l2,Pn)])] represents [#(l1:E1, ..., ln:En)], and the labels are
+            optional.
+
+            Invariant: [n >= 2]
+          *)
     | Pexp_construct of Longident.t loc * expression option
         (** [Pexp_construct(C, exp)] represents:
              - [C]               when [exp] is [None],
@@ -418,7 +461,7 @@ module Parsetree = struct
               - [for i = E1 downto E2 do E3 done]
                    when [direction] is {{!Asttypes.direction_flag.Downto}[Downto]}
            *)
-    | Pexp_constraint of expression * core_type  (** [(E : T)] *)
+    | Pexp_constraint of expression * core_type option * modes  (** [(E : T @@ modes)] *)
     | Pexp_coerce of expression * core_type option * core_type
         (** [Pexp_coerce(E, from, T)] represents
               - [(E :> T)]      when [from] is [None],
@@ -461,6 +504,7 @@ module Parsetree = struct
               - [let* P0 = E00 and* P1 = E01 in E1] *)
     | Pexp_extension of extension  (** [[%id]] *)
     | Pexp_unreachable  (** [.] *)
+    | Pexp_stack of expression
 
   and case (*IF_CURRENT = Parsetree.case *) =
     {
@@ -485,12 +529,83 @@ module Parsetree = struct
       pbop_loc : Location.t;
     }
 
+  and function_param_desc (*IF_CURRENT = Parsetree.function_param_desc *) =
+    | Pparam_val of arg_label * expression option * pattern
+    (** [Pparam_val (lbl, exp0, P)] represents the parameter:
+        - [P]
+          when [lbl] is {{!Asttypes.arg_label.Nolabel}[Nolabel]}
+          and [exp0] is [None]
+        - [~l:P]
+          when [lbl] is {{!Asttypes.arg_label.Labelled}[Labelled l]}
+          and [exp0] is [None]
+        - [?l:P]
+          when [lbl] is {{!Asttypes.arg_label.Optional}[Optional l]}
+          and [exp0] is [None]
+        - [?l:(P = E0)]
+          when [lbl] is {{!Asttypes.arg_label.Optional}[Optional l]}
+          and [exp0] is [Some E0]
+
+        Note: If [E0] is provided, only
+        {{!Asttypes.arg_label.Optional}[Optional]} is allowed.
+    *)
+    | Pparam_newtype of string loc * jkind_annotation loc option
+    (** [Pparam_newtype x] represents the parameter [(type x)].
+        [x] carries the location of the identifier, whereas the [pparam_loc]
+        on the enclosing [function_param] node is the location of the [(type x)]
+        as a whole.
+
+        Multiple parameters [(type a b c)] are represented as multiple
+        [Pparam_newtype] nodes, let's say:
+
+        {[ [ { pparam_kind = Pparam_newtype a; pparam_loc = loc1 };
+            { pparam_kind = Pparam_newtype b; pparam_loc = loc2 };
+            { pparam_kind = Pparam_newtype c; pparam_loc = loc3 };
+          ]
+        ]}
+
+        Here, the first loc [loc1] is the location of [(type a b c)], and the
+        subsequent locs [loc2] and [loc3] are the same as [loc1], except marked as
+        ghost locations. The locations on [a], [b], [c], correspond to the
+        variables [a], [b], and [c] in the source code.
+    *)
+
+  and function_param (*IF_CURRENT = Parsetree.function_param *) =
+    { pparam_loc : Location.t;
+      pparam_desc : function_param_desc;
+    }
+
+  and function_body (*IF_CURRENT = Parsetree.function_body *) =
+    | Pfunction_body of expression
+    | Pfunction_cases of case list * Location.t * attributes
+    (** In [Pfunction_cases (_, loc, attrs)], the location extends from the
+        start of the [function] keyword to the end of the last case. The compiler
+        will only use typechecking-related attributes from [attrs], e.g. enabling
+        or disabling a warning.
+    *)
+  (** See the comment on {{!expression_desc.Pexp_function}[Pexp_function]}. *)
+
+  and type_constraint (*IF_CURRENT = Parsetree.type_constraint *) =
+    | Pconstraint of core_type
+    | Pcoerce of core_type option * core_type
+  (** See the comment on {{!expression_desc.Pexp_function}[Pexp_function]}. *)
+
+  and function_constraint (*IF_CURRENT = Parsetree.function_constraint *) =
+    { mode_annotations : modes;
+      (** The mode annotation placed on a function let-binding when the function
+              has a type constraint on the body, e.g.
+              [let local_ f x : int -> int = ...].
+      *)
+      type_constraint : type_constraint;
+    }
+  (** See the comment on {{!expression_desc.Pexp_function}[Pexp_function]}. *)
+
   (** {2 Value descriptions} *)
 
   and value_description (*IF_CURRENT = Parsetree.value_description *) =
     {
       pval_name: string loc;
       pval_type: core_type;
+      pval_modalities : modalities;
       pval_prim: string list;
       pval_attributes: attributes;  (** [... [\@\@id1] [\@\@id2]] *)
       pval_loc: Location.t;
@@ -553,6 +668,7 @@ module Parsetree = struct
     {
       pld_name: string loc;
       pld_mutable: mutable_flag;
+      pld_modalities: modalities;
       pld_type: core_type;
       pld_loc: Location.t;
       pld_attributes: attributes;  (** [l : T [\@id1] [\@id2]] *)
@@ -578,8 +694,15 @@ module Parsetree = struct
       pcd_attributes: attributes;  (** [C of ... [\@id1] [\@id2]] *)
     }
 
+  and constructor_argument (*IF_CURRENT = Parsetree.constructor_argument *) =
+    {
+      pca_modalities: modalities;
+      pca_type: core_type;
+      pca_loc: Location.t;
+    }
+
   and constructor_arguments (*IF_CURRENT = Parsetree.constructor_arguments *) =
-    | Pcstr_tuple of core_type list
+    | Pcstr_tuple of constructor_argument list
     | Pcstr_record of label_declaration list
         (** Values of type {!constructor_declaration}
       represents the constructor arguments of:
@@ -896,7 +1019,7 @@ module Parsetree = struct
     | Psig_modtypesubst of module_type_declaration
         (** [module type S :=  ...]  *)
     | Psig_open of open_description  (** [open X] *)
-    | Psig_include of include_description  (** [include MT] *)
+    | Psig_include of include_description * modalities (** [include MT] *)
     | Psig_class of class_description list
         (** [class c1 : ... and ... and cn : ...] *)
     | Psig_class_type of class_type_declaration list
@@ -963,6 +1086,7 @@ module Parsetree = struct
 
   and 'a include_infos (*IF_CURRENT = 'a Parsetree.include_infos *) =
     {
+      pincl_kind: include_kind;
       pincl_mod: 'a;
       pincl_loc: Location.t;
       pincl_attributes: attributes;
@@ -1053,6 +1177,7 @@ module Parsetree = struct
     {
       pvb_pat: pattern;
       pvb_expr: expression;
+      pvb_modes: modes;
       pvb_attributes: attributes;
       pvb_loc: Location.t;
     }
@@ -1066,6 +1191,16 @@ module Parsetree = struct
     }
   (** Values of type [module_binding] represents [module X = ME] *)
 
+  and jkind_const_annotation = string Location.loc
+
+  and jkind_annotation (*IF_CURRENT = Parsetree.jkind_annotation *) =
+    | Default
+    | Abbreviation of jkind_const_annotation
+    | Mod of jkind_annotation * modes
+    | With of jkind_annotation * core_type
+    | Kind_of of core_type
+    | Product of jkind_annotation list
+
   (** {1 Toplevel} *)
 
   (** {2 Toplevel phrases} *)
