--- a/src/code_matcher.ml
+++ b/src/code_matcher.ml
@@ -1,4 +1,3 @@
-(*$ open Ppxlib_cinaps_helpers $*)
 open! Import
 module Format = Stdlib.Format
 module Filename = Stdlib.Filename
@@ -56,18 +55,53 @@ struct
     in
     loop [] l
 
-  let remove_loc =
+  (* When checking for whether the parsed code matches the expected code, there are
+     certain expected changes between the AST generated by ppxlib and the AST parsed
+     by the compiler and translated to match the ppxlib AST version.
+
+     Here, we normalize the AST so that these expected changes don't cause spurious
+     error messages about the round-trip check failing. *)
+  let traverse_normalize =
     object
-      inherit Ast_traverse.map
+      inherit Ast_traverse.map as super
+      (* Ignore locations *)
       method! location _ = Location.none
       method! location_stack _ = []
+
+
+
+      (* Drop erasable attributes encoding syntactic arity *)
+      method! attributes attrs =
+        List.filter attrs ~f:(fun { attr_name; _ } ->
+            not (String.starts_with attr_name.txt ~prefix:"jane.erasable._builtin"))
+        |> super#attributes
+
+
+
+      (* Reconcile how value binding constraints are handled between the two versions.
+         As of 2024-01-12, the AST generated by the compiler parse and translation inserts
+         an extra [Pexp_constraint] on the expression, as well as an unnecessary
+         [Ptyp_poly ([], ...)]. *)
+      method! value_binding ({ pvb_pat; pvb_expr; _ } as pvb) =
+        super#value_binding
+          (match pvb_pat.ppat_desc, pvb_expr.pexp_desc with
+           | ( Ppat_constraint (pat, Some { ptyp_desc = Ptyp_poly ([], pat_type); _ }, [])
+             , Pexp_constraint (expr, Some expr_type, []) )
+             when Poly.( = ) pat_type expr_type ->
+             { pvb with
+               pvb_pat = { pvb_pat with ppat_desc = Ppat_constraint (pat, Some pat_type, []) }
+             ; pvb_expr = expr
+             }
+           | _ -> pvb)
     end
 
+
   module M_map = M.Transform (struct
     type 'a t = 'a -> 'a
   end)
 
-  let remove_loc x = M_map.apply remove_loc x
+  let normalize x = M_map.apply traverse_normalize x
+
   let rec last prev = function [] -> prev | x :: l -> last x l
 
   let diff_asts ~generated ~round_trip =
@@ -127,11 +161,11 @@ struct
         mismatch_handler loc expected
     | x :: expected, y :: source ->
         let loc = M.get_loc y in
-        let x = remove_loc x in
-        let y = remove_loc y in
+        let x = normalize x in
+        let y = normalize y in
         if Poly.( <> ) x y then (
           let round_trip =
-            remove_loc (parse_string (Format.asprintf "%a@." M.pp x))
+            normalize (parse_string (Format.asprintf "%a@." M.pp x))
           in
           if Poly.( <> ) x round_trip then
             Location.raise_errorf ~loc
@@ -164,7 +198,7 @@ module Str = Make (struct
   let to_sexp = Ast_traverse.sexp_of#structure_item
 end)
 
-(*$ str_to_sig _last_text_block *)
+
 module Sig = Make (struct
   type t = signature_item
 
@@ -175,13 +209,11 @@ module Sig = Make (struct
     let apply o = o#signature_item
   end
 
-  let parse = Parse.interface
+  let parse x = let { psg_items } = Parse.interface x in psg_items
   let pp = Pprintast.signature_item
   let to_sexp = Ast_traverse.sexp_of#signature_item
 end)
 
-(*$*)
-
 let match_structure_res = Str.do_match
 
 let match_structure ~pos ~expected ~mismatch_handler l =
