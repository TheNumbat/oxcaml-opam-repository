diff --git a/core_unix/src/core_unix_stubs.c b/core_unix/src/core_unix_stubs.c
index 591fc88..2b3460e 100644
--- a/core_unix/src/core_unix_stubs.c
+++ b/core_unix/src/core_unix_stubs.c
@@ -514,9 +514,15 @@ static value ns_precision_stat_of_struct_stat(struct stat s) {
   Store_field(v_stat, 6, Val_int(s.st_gid));
   Store_field(v_stat, 7, Val_int(s.st_rdev));
   Store_field(v_stat, 8, Val_file_offset(s.st_size));
+#ifdef __APPLE__
+  Store_field(v_stat, 9, caml_alloc_int63(timespec_to_int_ns(s.st_atimespec)));
+  Store_field(v_stat, 10, caml_alloc_int63(timespec_to_int_ns(s.st_mtimespec)));
+  Store_field(v_stat, 11, caml_alloc_int63(timespec_to_int_ns(s.st_ctimespec)));
+#else
   Store_field(v_stat, 9, caml_alloc_int63(timespec_to_int_ns(s.st_atim)));
   Store_field(v_stat, 10, caml_alloc_int63(timespec_to_int_ns(s.st_mtim)));
   Store_field(v_stat, 11, caml_alloc_int63(timespec_to_int_ns(s.st_ctim)));
+#endif
   CAMLreturn(v_stat);
 }
 
@@ -1561,9 +1567,14 @@ CAMLprim value core_unix_strptime(value v_locale, value v_allow_trailing_input,
                                   value v_fmt, value v_s) {
   locale_t locale = (locale_t)Nativeint_val(v_locale);
   struct tm tm = {0};
+#ifdef __APPLE__
+  // On macOS, strptime_l may not be available or reliable
+  char *end_of_consumed_input = strptime(String_val(v_s), String_val(v_fmt), &tm);
+#else
   char *end_of_consumed_input =
       locale == (locale_t)0 ? strptime(String_val(v_s), String_val(v_fmt), &tm)
                             : strptime_l(String_val(v_s), String_val(v_fmt), &tm, locale);
+#endif
   if (!end_of_consumed_input)
     caml_failwith("unix_strptime: match failed");
   if (!Bool_val(v_allow_trailing_input) &&
@@ -2055,7 +2066,32 @@ CAMLprim value core_unix_execvpe(value v_prog, value v_args, value v_env) {
   char *env_storage[nenv + 1];
   char *const *envp = fill_args(env_storage, nenv, v_env);
 
+#ifdef __APPLE__
+  // macOS doesn't have execvpe, so we need to search PATH manually
+  if (strchr(path, '/') != NULL) {
+    // Path contains '/', use execve directly
+    execve(path, argv, envp);
+  } else {
+    // Search PATH for the executable
+    char *path_env = getenv("PATH");
+    if (path_env) {
+      char *path_copy = strdup(path_env);
+      char *dir = strtok(path_copy, ":");
+      while (dir != NULL) {
+        char full_path[PATH_MAX];
+        snprintf(full_path, sizeof(full_path), "%s/%s", dir, path);
+        execve(full_path, argv, envp);
+        // If execve succeeds, it doesn't return
+        dir = strtok(NULL, ":");
+      }
+      free(path_copy);
+    }
+    // If we get here, execve failed for all paths
+    errno = ENOENT;
+  }
+#else
   execvpe(path, argv, envp);
+#endif
 
   caml_uerror("execvpe", v_prog);
 }
diff --git a/core_unix/src/core_unix_time_stubs.c b/core_unix/src/core_unix_time_stubs.c
index 729f698..a5728f1 100644
--- a/core_unix/src/core_unix_time_stubs.c
+++ b/core_unix/src/core_unix_time_stubs.c
@@ -4,6 +4,10 @@
 #include <string.h>
 #include <time.h>
 #include <unistd.h>
+#include <locale.h>
+#ifdef __APPLE__
+#include <xlocale.h>
+#endif
 #include <caml/mlvalues.h>
 #include <caml/alloc.h>
 #include <caml/custom.h>
diff --git a/core_unix/src/locale_stubs.c b/core_unix/src/locale_stubs.c
index fd67b26..3021cdf 100644
--- a/core_unix/src/locale_stubs.c
+++ b/core_unix/src/locale_stubs.c
@@ -5,6 +5,9 @@
 #include <langinfo.h>
 #include <locale.h>
 #include <string.h>
+#ifdef __APPLE__
+#include <xlocale.h>
+#endif
 #include <caml/alloc.h>
 #include <caml/mlvalues.h>
 #include <caml/unixsupport.h>
@@ -124,8 +127,24 @@ CAMLprim value unix_getlocalename(int32_t category, intnat i_locale) {
       if (!result || !*result)
         uerror("nl_langinfo_l", Nothing);
       return caml_copy_string(result);
-#elif defined __APPLE__ || defined __FreeBSD__ || defined __NetBSD__ ||                  \
-    defined __OpenBSD__
+#elif defined __APPLE__
+      // macOS has different locale mask values and uses querylocale
+      int mask;
+      switch (category) {
+        case LC_COLLATE: mask = LC_COLLATE_MASK; break;
+        case LC_CTYPE: mask = LC_CTYPE_MASK; break;
+        case LC_MESSAGES: mask = LC_MESSAGES_MASK; break;
+        case LC_MONETARY: mask = LC_MONETARY_MASK; break;
+        case LC_NUMERIC: mask = LC_NUMERIC_MASK; break;
+        case LC_TIME: mask = LC_TIME_MASK; break;
+        default: caml_invalid_argument("invalid locale category"); break;
+      }
+      errno = 0;
+      const char *result = querylocale(mask, locale);
+      if (!result || !*result)
+        uerror("querylocale", Nothing);
+      return caml_copy_string(result);
+#elif defined __FreeBSD__ || defined __NetBSD__ || defined __OpenBSD__
       // Here we rely on LC_*_MASK == 1 << LC_* for the standard categories *, which we
       // static assert on:
       static_assert(LC_CTYPE_MASK == 1 << LC_CTYPE, "");
diff --git a/time_stamp_counter/src/time_stamp_counter.ml b/time_stamp_counter/src/time_stamp_counter.ml
index 9720244..7cceb20 100644
--- a/time_stamp_counter/src/time_stamp_counter.ml
+++ b/time_stamp_counter/src/time_stamp_counter.ml
@@ -97,7 +97,7 @@ let zero = Int63.zero
 [%%ifdef JSC_ARCH_SIXTYFOUR]
 
 external rdtsc : unit -> (int64[@unboxed]) = "caml_rdtsc" "caml_rdtsc_unboxed"
-[@@noalloc] [@@builtin]
+[@@noalloc] (* [@@builtin] *)
 
 (* noalloc on x86_64 only *)
 let[@inline] now () =
