diff --git a/kernel/heartbeat_stubs.c b/kernel/heartbeat_stubs.c
index e17d9ee..10c5529 100644
--- a/kernel/heartbeat_stubs.c
+++ b/kernel/heartbeat_stubs.c
@@ -6,6 +6,9 @@
 #include <pthread.h>
 #include <time.h>
 #include <errno.h>
+#ifdef __APPLE__
+#include <mach/mach_time.h>
+#endif
 
 struct Custom_Atomic {
   header_t header;
@@ -19,25 +22,62 @@ CAMLprim value parallel_heartbeat_counter(__attribute__((unused)) value unit) {
   return (value)&heartbeat_counter.count;
 }
 
+#ifdef __APPLE__
+static void crossplatform_sleep(long interval_us) {
+  uint64_t start = mach_absolute_time();
+  uint64_t target_ns = (uint64_t)interval_us * 1000;
+  
+  static mach_timebase_info_data_t timebase_info;
+  if (timebase_info.denom == 0) {
+    mach_timebase_info(&timebase_info);
+  }
+  
+  uint64_t target_mach = target_ns * timebase_info.denom / timebase_info.numer;
+  uint64_t end_time = start + target_mach;
+  
+  while (true) {
+    uint64_t now = mach_absolute_time();
+    if (now >= end_time) break;
+    
+    uint64_t remaining_mach = end_time - now;
+    uint64_t remaining_ns = remaining_mach * timebase_info.numer / timebase_info.denom;
+    
+    struct timespec sleep_time = {
+      .tv_sec = remaining_ns / 1000000000,
+      .tv_nsec = remaining_ns % 1000000000
+    };
+    
+    struct timespec remain = {0};
+    int err = nanosleep(&sleep_time, &remain);
+    if (err == -1 && errno != EINTR) {
+      caml_fatal_error("Heartbeat thread failed to sleep: %d\n", errno);
+    }
+  }
+}
+#else
+static void crossplatform_sleep(long interval_us) {
+  struct timespec interval = {0};
+  interval.tv_nsec = interval_us * 1000;
+  
+  struct timespec remain = {0};
+  int err = clock_nanosleep(CLOCK_MONOTONIC, 0, &interval, &remain);
+  while (err == EINTR) {
+    err = clock_nanosleep(CLOCK_MONOTONIC, 0, &remain, &remain);
+  }
+  if (err) {
+    caml_fatal_error("Heartbeat thread failed to sleep: %d\n", err);
+  }
+}
+#endif
+
 static void *heartbeat_thread(void *interval_us) {
 
   // We do not hold a domain lock, so we must not interact with the OCaml runtime.
   // However, we cheat and update [heartbeat_counter] because we know it is not
   // GC-managed.
 
-  struct timespec interval = {0};
-  interval.tv_nsec = (long)interval_us * 1000;
-
   while (true) {
-    struct timespec remain = {0};
-    int err = clock_nanosleep(CLOCK_MONOTONIC, 0, &interval, &remain);
-    while (err == EINTR) {
-      err = clock_nanosleep(CLOCK_MONOTONIC, 0, &remain, &remain);
-    }
-
-    if (err) {
-      caml_fatal_error("Heartbeat thread failed to sleep: %d\n", err);
-    }
+    crossplatform_sleep((long)interval_us);
 
     // Adding two increments the tagged count.
     atomic_fetch_add(&heartbeat_counter.count, 2);